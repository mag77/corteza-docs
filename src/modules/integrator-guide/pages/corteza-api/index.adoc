include::ROOT:partial$variables.adoc[]

= Working with the API

// I'll go over working with the API first, so that that base is covered.
// All further things rely quite heavily on the API so this makes the most sense.

Corteza separates the back-end business logic and the front-end user interface by defining an API that the clients (web applications and other custom applications) can access.
All operations that can be performed via user interfaces, can be performed via an API call (or a series of API calls); everything from creating users to importing records from CSV files.

The API follows the RESTful standard, using JSON as the data format for data transfer.

[IMPORTANT]
====
Error responses use the status code 200 OK, instead of the standard 4xx/5xx -- legacy reasons.
Our SDK covers this case and throws proper errors.
====

== Authentication

Corteza uses bearer JWT tokens for authentication purposes.
To obtain a JWT token you must go through the sign up/sign in process.
The same JWT token can be used inside web applications and other custom applications/clients (such as cURL).

[TIP]
====
Web applications store the JWT token inside local storage under `auth.jwt`.
You can use that token to authenticate your HTTP requests.
====

[IMPORTANT]
====
Make sure to treat the JWT token as a secret credential as it allows access to the system.
====

Most endpoints (exceptions listed bellow) require you to authenticate your requests with bearer JWT tokens using the `authorization` header.
Unauthorized requests yield an error response of `{ "error": { "message": "Unauthorized" } }` (or similar).

.An example cURL with authentication:
[source,bash]
----
curl "$CORTEZA_URL" \
  -H 'accept: application/json, text/plain, */*' \
  -H "authorization: Bearer $JWT";
----

.An example cURL without authentication:
[source,bash]
----
curl "$CORTEZA_URL" \
  -H 'accept: application/json, text/plain, */*';
----

The below tables list endpoints with alternative authentication mechanisms (if any at all).

.System endpoints with alternative request authentication:
[cols="1m,5a"]
|===
| Endpoint
| Other authentication methods

| `GET /attachment/{kind}/{attachmentID}/original/{name}`
| System generated signature.

| `GET /attachment/{kind}/{attachmentID}/preview.{ext}`
| System generated signature.

// ----

| `GET /auth/`
| None.

| `GET /auth/check`
| None.

| `POST /auth/exchange`
| None.

| `GET /auth/logout`
| None.

| `POST /auth/internal/login`
| None.

| `POST /auth/internal/signup`
| None.

| `POST /auth/internal/request-password-reset`
| None.

| `POST /auth/internal/exchange-password-reset-token`
| System generated password reset token.

| `POST /auth/internal/reset-password`
| System generated password reset token.

| `POST /auth/internal/confirm-email`
| System generated token.

// ----

| `* /sink/*`
| System generated sink signature.

|===

.Compose endpoints with alternative request authentication:
[cols="1m,5a"]
|===
| Endpoint
| Other authentication methods

| `GET /namespace/{namespaceID}/attachment/{kind}/{attachmentID}/original/{name}`
| System generated signature.

| `GET /namespace/{namespaceID}/attachment/{kind}/{attachmentID}/preview.{ext}`
| System generated signature.

|===

.Messaging endpoints with alternative request authentication:
[cols="1m,5a"]
|===
| Endpoint
| Other authentication methods

| `GET /attachment/{attachmentID}/original/{name}`
| System generated signature.

| `GET /attachment/{attachmentID}/preview.{ext}`
| System generated signature.

|===

.Federation endpoints with alternative request authentication:
[cols="1m,5a"]
|===
| Endpoint
| Other authentication methods

| `POST /nodes/{nodeID}/handshake`
| System generated OTT token.

|===

== Response data format

Corteza implements three different response formats, based on what we are trying to do/success status.

.The three formats are:
* operating over a single item (read, create, update),
* operating over multiple items (listing, filtering),
* operation error.

.When working with single items, the response is formatted like this:
[source,json]
----
{
  "response": {...}
}
----

.When working with multiple items, the response is formatted like this:
[source,json]
----
{
  "response": {
    "filter": {...},
    "set": [...]
  }
}
----

[NOTE]
====
The structure of the `filter` property differs based on the resource.
In general it specifies what filters were applied to the responding set.
====

.When an operation error occurs, the response is formatted like this:
[source,json]
----
{
  "error": {
    "message": "..."
  }
}
----

[NOTE]
====
When enabled via `HTTP_ERROR_TRACING`, the error also includes a stack trace for easier debugging.
It's recommended to keep this disabled in production environments.

.The response is formatted like this:
[source,json]
----
{
  "error": {
    "message": "...",
    "stack": [...],
    "wrap": {...}
  }
}
----

====

== Paging

[NOTE]
====
As of 2020.12, Corteza moved away from standard page and offset to page cursors.
The change is *not backwards compatible*.
====

When a specific operation supports paging (such as fetching records and modules), the `filter` property in the response object contains paging properties.

.The `filter` contains:
[source,json]
----
{
  "limit": ...<1>
  "cursor": "..."<2>
  "nextPage": "..."<3>
  "prevPage": "..."<4>
}
----
<1> `limit` (number) specifies the maximum number of items that can be returned in this page.
<2> `cursor` (string) specifies the cursor to the current page.
<3> `nextPage` (string) specifies the next page.
<4> `prevPage` (string) specifies the previous page.

When wanting to access the next page, the `pageCursor=$PAGE_CURSOR` query parameter must be provided.
For example `curl -X GET "$API_BASE/compose/namespace/$NAMESPACE_ID/module/$MODULE_ID/record/?pageCursor=$PAGE_CURSOR";`

== Endpoints

Each Corteza instance comes built-in with an API reference (generated with Swagger) that can be accessed on the `/docs` endpoint of your Corteza API.
Refer to the full API reference to see all available endpoints and what parameters they accept.

[NOTE]
====
If you are using a different container (different webapp, api subdomains) for your API, the API reference URL should look something like `https://api.$BASE_URL/docs`.

If you are not using a different container (same webapp, api subdomain) for your API, the API reference URL should look something like `https://$BASE_URL/api/docs`.
====

.The system is split into four main endpoints for the four different services:
* `/system` lets you operate over the *core system*, such as authentication, creating new users and assigning roles.
* `/compose` lets you operate over *compose*, such as creating new modules and and records.
* `/messaging` lets you operate over *messaging*, such as creating channels and sending messages.
* `/federation` lets you operate over *federation*, such as pairing nodes and fetching changes.

.Additionally, you can explicitly enable some debugging routes:
[cols="1m,5a"]
|===
| Option
| Endpoints

| HTTP_ENABLE_DEBUG_ROUTE
|
* `/__profiler` provides server runtime profiling data in the format expected by the pprof visualization tool.
* `/__routes` provides a list of all registered routes.
* `/__eventbus` provides a list of all registered automation script triggers.
* `/__corredor` provides a list of all registered automation scripts.

| HTTP_ENABLE_VERSION_ROUTE
|
* `/version` shows the build time and the Corteza version.

| HTTP_ENABLE_HEALTHCHECK_ROUTE
|
* `/healthcheck` performs and displays the system health check.

|===

[NOTE]
====
It's a good idea to keep `HTTP_ENABLE_DEBUG_ROUTE` set as `false` on production environments.
`HTTP_ENABLE_VERSION_ROUTE` and `HTTP_ENABLE_HEALTHCHECK_ROUTE` should also be disabled, but can come in handy for quick checkups.
====

---

*Each {PRODUCT_NAME} instance* has its own *API reference built-in* so that the reference is always there and always valid.
Navigate to the `/docs/` API sub-page; for example `https://api.{API_DOMAIN}/docs`.

Alternatively, you can use our community instance https://api.latest.cortezaproject.org/docs/

[NOTE]
====
Our community instance is always on the *latest stable version* so the *reference may not be compatible*.
====

